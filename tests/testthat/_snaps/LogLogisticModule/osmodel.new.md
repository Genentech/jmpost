# merge is working as expected

    Code
      LogLogisticModule()
    Output
      An object of class "StanModule"
      Slot "functions":
      [1] "  matrix log_h0(matrix time, real lambda, real p) {\n    matrix[rows(time), cols(time)] lambda_t = lambda * time;\n    matrix[rows(time), cols(time)] log_num = log(lambda) + log(p) + (p - 1) * log(lambda_t);\n    matrix[rows(time), cols(time)] log_denom = log1p(lambda_t ^ p);\n    matrix[rows(time), cols(time)] result = log_num - log_denom;\n    return result;\n  }\n\n  matrix log_hazard(matrix time,\n  real lambda, real p, <link_arguments>\n  row_vector psi_bsld, row_vector psi_ks, row_vector psi_kg, row_vector psi_phi,\n  vector beta_os_cov, data matrix os_cov_design) {\n    row_vector[rows(os_cov_design)] cov_contribution;\n    matrix[rows(time), cols(time)] log_baseline = log_h0(time, lambda, p);\n    if (rows(os_cov_design) > 1) {\n      cov_contribution = (os_cov_design * beta_os_cov)';\n    } else {\n      cov_contribution[1] = (os_cov_design * beta_os_cov)[1];\n    }\n    matrix[rows(time), cols(cov_contribution)] cov_contribution_matrix = rep_matrix(cov_contribution, rows(time));\n    matrix[rows(time), cols(time)] result =  <link_log_hazard_contribution> + log_baseline + cov_contribution_matrix;\n    return result;\n  }\n\n  row_vector log_survival(row_vector time, real lambda,\n  real p, <link_arguments>\n  row_vector psi_bsld, row_vector psi_ks, row_vector psi_kg, row_vector psi_phi,\n  data vector nodes, data row_vector weights, vector beta_os_cov, data matrix os_cov_design) {\n    int time_positive[cols(time)] = is_positive(time);\n    int n_positive = sum(time_positive);\n    int time_positive_index[n_positive] = which(time_positive);\n    row_vector[cols(time)] result = rep_row_vector(0.0, cols(time));\n\n    matrix[rows(nodes), n_positive] nodes_time = (nodes + 1) * (time[time_positive_index] / 2);\n    matrix[rows(nodes), n_positive] nodes_time_hazard = fmin(8000.0, exp(log_hazard(nodes_time, lambda,\n    p, <link_arguments_as_par>,\n    psi_bsld[time_positive_index],\n    psi_ks[time_positive_index],\n    psi_kg[time_positive_index],\n    psi_phi[time_positive_index], beta_os_cov, os_cov_design[time_positive_index])));\n    result[time_positive_index] = - (weights * nodes_time_hazard) .* time[time_positive_index] / 2;\n    return result;\n  }\n\n  real neg_log_sqrt_2_pi() {\n    return -0.9189385332046727;\n  }\n\n\n  row_vector vect_normal_log_dens(row_vector y, row_vector mu, row_vector sigma) {\n    row_vector[num_elements(y)] y_stand = (y - mu) ./ sigma;\n    row_vector[num_elements(y)] main_result = - (y_stand .* y_stand) / 2;\n    return main_result + neg_log_sqrt_2_pi() - log(sigma);\n  }\n\n  row_vector vect_normal_log_cum(real quantile, row_vector mu, row_vector sigma) {\n    row_vector[num_elements(mu)] quant_stand = (quantile - mu) ./ sigma;\n    row_vector[num_elements(mu)] cdf_vals = Phi(quant_stand);\n    return log(cdf_vals);\n  }\n\n  row_vector row_means(matrix x) {\n    row_vector[cols(x)] result = rep_row_vector(1.0 / rows(x), rows(x)) * x;\n    return result;\n  }\n\n  row_vector get_step_survival(real death_time, row_vector times) {\n    row_vector[cols(times)] result;\n    for (i in 1:cols(times)) {\n      result[i] = times[i] < death_time;\n    }\n    return result;\n  }\n\n\n  row_vector get_cond_survival(real cens_surv_prob, row_vector uncond_surv_probs) {\n    row_vector[cols(uncond_surv_probs)] result = fmin(1.0, uncond_surv_probs / cens_surv_prob);\n    return result;\n  }"
      
      Slot "data":
      [1] "  row_vector[Nind] Times;\n  int Death[Nind];\n  int<lower=1> p_os_cov_design;\n  matrix[Nind, p_os_cov_design] os_cov_design;\n\n\n  int<lower=1> n_os_pred_times;\n  row_vector<lower=0>[n_os_pred_times] os_pred_times;\n\n  int<lower=1> n_nodes;\n  vector[n_nodes] nodes;\n  row_vector<lower=0, upper=1>[n_nodes] weights;"
      
      Slot "parameters":
      [1] "  real<lower=0> p;\n  real<lower=0> lambda; // For the log-logistic baseline hazard.\n  <link_parameters>\n  vector[p_os_cov_design] beta_os_cov; // Covariate coefficients."
      
      Slot "transformed_parameters":
      [1] " log_surv_vals = log_survival(Times, lambda, p, <link_log_surv>\n  psi_bsld, psi_ks, psi_kg, psi_phi,\n  nodes, weights, beta_os_cov, os_cov_design);\n  log_lik += log_surv_vals;\n\n  log_lik[dead_ind_index] += to_row_vector(log_hazard(to_matrix(Times[dead_ind_index]), lambda, p, <link_log_lik>\n  psi_bsld[dead_ind_index], psi_ks[dead_ind_index], psi_kg[dead_ind_index], psi_phi[dead_ind_index],\n  beta_os_cov, os_cov_design[dead_ind_index]));"
      
      Slot "model":
      [1] "target+=sum(log_lik);\n"
      
      Slot "priors":
      $p
      [1] "gamma(2, 0.5);"
      
      $`1/lambda`
      [1] "lognormal(0, 5);"
      
      $beta_os_cov
      [1] "normal(0, 5);"
      
      
      Slot "generated_quantities":
      [1] "  matrix[n_arms, n_os_pred_times] mean_unconditional_survival;\n  matrix[n_arms, n_os_pred_times] mean_conditional_survival;\n  matrix[n_arms, n_os_pred_times] mean_hazard;\n  matrix[n_arms, n_os_pred_times] mean_log_hazard;\n\n\n  matrix[n_save_individual, n_os_pred_times] save_ind_unconditional_survival;\n  matrix[n_save_individual, n_os_pred_times] save_ind_conditional_survival;\n  matrix[n_save_individual, n_os_pred_times] save_ind_log_hazard;\n  row_vector[n_save_individual] save_ind_ttg;\n  matrix[n_save_individual, n_os_pred_times] save_ind_dtsld;\n\n  // Local scope - these will not be returned, only used here temporarily.\n  {\n    matrix[Nind, n_os_pred_times] ind_unconditional_survival;\n    matrix[Nind, n_os_pred_times] ind_conditional_survival;\n    matrix[Nind, n_os_pred_times] ind_log_hazard;\n    int i_rep[n_os_pred_times];\n    real surv_prob_at_cens;\n    int index_pos;\n\n    // Process each patient.\n    for (i in 1:Nind) {\n      i_rep = rep_array(i, n_os_pred_times);\n\n      // Unconditional survival.\n      ind_unconditional_survival[i] = exp(log_survival(os_pred_times,\n      lambda, p, <link_arguments_as_par>,\n      psi_bsld[i_rep], psi_ks[i_rep], psi_kg[i_rep], psi_phi[i_rep],\n      nodes, weights, beta_os_cov, os_cov_design[i_rep]));\n\n      // Conditional survival.\n      if (Death[i]) {\n        ind_conditional_survival[i] = get_step_survival(Times[i], os_pred_times);\n      } else {\n        surv_prob_at_cens = exp(log_surv_vals[i]);\n        ind_conditional_survival[i] = get_cond_survival(surv_prob_at_cens,\n        ind_unconditional_survival[i]);\n      }\n\n      // Log hazard.\n      ind_log_hazard[i] = to_row_vector(log_hazard(to_matrix(os_pred_times),\n      lambda, p,  <link_arguments_as_par>,\n      psi_bsld[i_rep], psi_ks[i_rep], psi_kg[i_rep], psi_phi[i_rep],\n      beta_os_cov, os_cov_design[i_rep]));\n    }\n\n    // Process each treatment arm.\n    index_pos = 1;\n    for (j in 1:n_arms) {\n      mean_unconditional_survival[j] =\n      row_means(ind_unconditional_survival[segment(index_per_arm, index_pos, n_index_per_arm[j])]);\n\n      mean_conditional_survival[j] =\n      row_means(ind_conditional_survival[segment(index_per_arm, index_pos, n_index_per_arm[j])]);\n\n      mean_log_hazard[j] =\n      row_means(ind_log_hazard[segment(index_per_arm, index_pos, n_index_per_arm[j])]);\n\n      mean_hazard[j] =\n      row_means(exp(ind_log_hazard[segment(index_per_arm, index_pos, n_index_per_arm[j])]));\n\n      index_pos = index_pos + n_index_per_arm[j];\n    }\n\n    // Save specific individual quantities.\n    save_ind_unconditional_survival = ind_unconditional_survival[index_save_individual];\n    save_ind_conditional_survival = ind_conditional_survival[index_save_individual];\n    save_ind_log_hazard = ind_log_hazard[index_save_individual];\n    save_ind_ttg = ttg(psi_ks[index_save_individual], psi_kg[index_save_individual], psi_phi[index_save_individual]);\n    save_ind_dtsld = (dtsld(rep_matrix(os_pred_times', n_save_individual),\n    psi_bsld[index_save_individual], psi_ks[index_save_individual], psi_kg[index_save_individual], psi_phi[index_save_individual]))';\n\n  }"
      
      Slot "inits":
      list()
      

