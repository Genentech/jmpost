





test_that("Grid objects work with QuantityGenerator and QuantityCollapser", {
    dat_os <- dplyr::tibble(
        pt = c("A", "B", "C", "D"),
        arm = c("Arm-A", "Arm-A", "Arm-B", "Arm-B"),
        study = c("Study-1", "Study-1", "Study-1", "Study-1"),
        time = c(1, 2, 3, 4),
        event = c(1, 1, 0, 1)
    )


    dat_lm <- dplyr::tibble(
        pt = c("A", "A", "A", "B", "B", "B", "C", "C", "C", "D", "D", "D"),
        time = c(1, 2, 3, 10, 20, 30, 100, 200, 300, 1000, 2000, 3000),
        sld = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
    )

    dj <- DataJoint(
        subject = DataSubject(
            data = dat_os,
            subject = "pt",
            arm = "arm",
            study = "study"
        ),
        survival = DataSurvival(
            data = dat_os,
            formula = Surv(time, event) ~ 1
        ),
        longitudinal = DataLongitudinal(
            data = dat_lm,
            formula = sld ~ time,
            threshold = 5
        )
    )

    #
    # GridFixed
    #
    grid <- GridFixed(
        subjects = c("A", "B", "D"),
        times = c(1, 4)
    )
    actual <- as.QuantityGenerator(grid, data = dj)
    expected <- .QuantityGenerator(
        subjects = c("A", "B", "D", "A", "B", "D"),
        times = c(1, 1, 1, 4, 4, 4)
    )
    expect_equal(actual, expected)

    actual <- as.QuantityCollapser(grid, data = dj)
    expected <- .QuantityCollapser(
        groups = c("A", "B", "D", "A", "B", "D"),
        times = c(1, 1, 1, 4, 4, 4),
        indexes = list(1, 2, 3, 4, 5, 6)
    )
    expect_equal(actual, expected)


    #
    # GridGrouped
    #
    grid <- GridGrouped(
        groups = list("G1" = c("A", "D"), "G2" = c("A", "B")),
        times = c(1, 4)
    )
    actual <- as.QuantityGenerator(grid, data = dj)
    expected <- .QuantityGenerator(
        subjects = c("A", "D", "B", "A", "D", "B"),
        times = c(1, 1, 1, 4, 4, 4)
    )
    expect_equal(actual, expected)

    actual <- as.QuantityCollapser(grid, data = dj)
    expected <- .QuantityCollapser(
        groups = c("G1", "G2", "G1", "G2"),
        times = c(1, 1, 4, 4),
        indexes = list(c(1, 2), c(1, 3), c(4, 5), c(4, 6))
    )
    expect_equal(actual, expected)


    #
    # GridObserved
    #
    grid <- GridObserved(
        subjects = c("C", "A")
    )
    actual <- as.QuantityGenerator(grid, data = dj)
    expected <- .QuantityGenerator(
        subjects = c("C", "C", "C", "A", "A", "A"),
        times = c(100, 200, 300, 1, 2, 3)
    )
    expect_equal(actual, expected)

    actual <- as.QuantityCollapser(grid, data = dj)
    expected <- .QuantityCollapser(
        groups = c("C", "C", "C", "A", "A", "A"),
        times = c(100, 200, 300, 1, 2, 3),
        indexes = list(1, 2, 3, 4, 5, 6)
    )
    expect_equal(actual, expected)


    #
    # GridManual
    #
    grid <- GridManual(
        spec = list(
            "B" = c(2, 4),
            "A" = c(1, 10, 50),
            "C" = 6
        )
    )
    actual <- as.QuantityGenerator(grid, data = dj)
    expected <- .QuantityGenerator(
        subjects = c("B", "B", "A", "A", "A", "C"),
        times = c(2, 4, 1, 10, 50, 6)
    )
    expect_equal(actual, expected)

    actual <- as.QuantityCollapser(grid, data = dj)
    expected <- .QuantityCollapser(
        groups = c("B", "B", "A", "A", "A", "C"),
        times = c(2, 4, 1, 10, 50, 6),
        indexes = list(1, 2, 3, 4, 5, 6)
    )
    expect_equal(actual, expected)



    #
    # GridEven
    #
    grid <- GridEven(
        subjects = c("D", "A"),
        length.out = 4
    )
    actual <- as.QuantityGenerator(grid, data = dj)
    expected <- .QuantityGenerator(
        subjects = c("D", "D", "D", "D", "A", "A", "A", "A"),
        times = c(
            seq(1000, 3000, length.out = 4),
            seq(1, 3, length.out = 4)
        )
    )
    expect_equal(actual, expected)

    actual <- as.QuantityCollapser(grid, data = dj)
    expected <- .QuantityCollapser(
        groups = expected@subjects,
        times = expected@times,
        indexes = as.list(seq_along(expected@times))
    )
    expect_equal(actual, expected)

})






test_that("GridObservered + Constructs correct quantities", {

    #
    # This test essentially works by attempting to construct the generated
    # quantities by hand and then testing to show that they match the values
    # generated by the jmpost functions
    #

    set.seed(739)
    jlist <- SimJointData(
        design = list(
            SimGroup(50, "Arm-A", "Study-X"),
            SimGroup(30, "Arm-B", "Study-X")
        ),
        survival = SimSurvivalExponential(
            lambda = 1 / (400 / 365),
            time_max = 4,
            time_step = 1 / 365,
            lambda_censor = 1 / 9000,
            beta_cat = c(
                "A" = 0,
                "B" = -0.1,
                "C" = 0.5
            ),
            beta_cont = 0.3
        ),
        longitudinal = SimLongitudinalGSF(
            times = seq(0, 4, by = 1 / 365),
            sigma = 0.01,
            mu_s = c(0.6, 0.4),
            mu_g = c(0.25, 0.35),
            mu_b = 60,
            a_phi = c(15, 15),
            b_phi = c(15, 15),
            omega_b = 0.2,
            omega_s = 0.2,
            omega_g = 0.2
        ),
        .silent = TRUE
    )


    dat_os <- jlist@survival
    dat_lm <- jlist@longitudinal |>
        dplyr::group_by(pt) |>
        dplyr::sample_n(9) |>
        dplyr::group_by(pt) |>
        dplyr::filter(!pt == "pt_004" | seq_len(dplyr::n()) <= 7) |>
        dplyr::ungroup()


    jm <- JointModel(
        longitudinal = LongitudinalGSF(
            mu_bsld = prior_normal(log(60), 0.5),
            mu_ks = prior_normal(log(0.6), 0.5),
            mu_kg = prior_normal(log(0.3), 0.5),
            omega_bsld = prior_lognormal(log(0.2), 0.5),
            omega_ks = prior_lognormal(log(0.2), 0.5),
            omega_kg = prior_lognormal(log(0.2), 0.5),
            a_phi = prior_lognormal(log(15), 0.5),
            b_phi = prior_lognormal(log(15), 0.5),
            sigma = prior_lognormal(log(0.01), 0.5),
            centred = TRUE
        ),
        survival = SurvivalExponential(
            lambda = prior_lognormal(log(1 / (400 / 365)), 1)
        ),
        link = Link()
    )

    jdat <- DataJoint(
        subject = DataSubject(
            data = dat_os,
            subject = "pt",
            arm = "arm",
            study = "study"
        ),
        survival = DataSurvival(
            data = dat_os,
            formula = Surv(time, event) ~ cov_cat + cov_cont
        ),
        longitudinal = DataLongitudinal(
            data = dat_lm,
            formula = sld ~ time
        )
    )

    mp <- run_quietly({
        sampleStanModel(
            jm,
            data = jdat,
            iter_sampling = 100,
            iter_warmup = 100,
            chains = 1,
            refresh = 0,
            parallel_chains = 1
        )
    })



    #
    #
    # Longitudinal Data
    #
    #
    longquant_obsv <- LongitudinalQuantities(
        mp,
        grid = GridObserved(
            subjects = c("pt_004", "pt_002", "pt_050")
        )
    )
    actual_obsv <- summary(longquant_obsv)


    longquant_manual <- LongitudinalQuantities(
        mp,
        grid = GridManual(
            spec = list(
                "pt_004" = dat_lm |> dplyr::filter(pt == "pt_004") |> dplyr::arrange(time) |> dplyr::pull(time),
                "pt_002" = dat_lm |> dplyr::filter(pt == "pt_002") |> dplyr::arrange(time) |> dplyr::pull(time),
                "pt_050" = dat_lm |> dplyr::filter(pt == "pt_050") |> dplyr::arrange(time) |> dplyr::pull(time)
            )
        )
    )
    actual_manual <- summary(longquant_manual)

    expect_equal(actual_obsv, actual_manual)


    pred_mat <- as.CmdStanMCMC(mp)$draws("Ypred", format = "draws_matrix")

    fdat <- dat_lm |>
        dplyr::arrange(pt, time, sld) |>
        dplyr::mutate(index = seq_len(dplyr::n())) |>
        dplyr::filter(pt %in% c("pt_004", "pt_002", "pt_050"))

    times <- c(
        fdat |> dplyr::filter(pt == "pt_004") |> dplyr::pull(time),
        fdat |> dplyr::filter(pt == "pt_002") |> dplyr::pull(time),
        fdat |> dplyr::filter(pt == "pt_050") |> dplyr::pull(time)
    )

    indexes <- c(
        fdat |> dplyr::filter(pt == "pt_004") |> dplyr::pull(index),
        fdat |> dplyr::filter(pt == "pt_002") |> dplyr::pull(index),
        fdat |> dplyr::filter(pt == "pt_050") |> dplyr::pull(index)
    )

    preds_reduced <- pred_mat[, indexes]
    expected <- dplyr::tibble(
        group = rep(c("pt_004", "pt_002", "pt_050"), c(7, 9, 9)),
        time = times,
        median = apply(preds_reduced, 2, median),
        lower = apply(preds_reduced, 2, quantile, 0.025),
        upper = apply(preds_reduced, 2, quantile, 0.975)
    )

    expect_gt(cor(actual_obsv$median, expected$median), 0.99999999)
    expect_gt(cor(actual_obsv$lower, expected$lower), 0.99999999)
    expect_gt(cor(actual_obsv$upper, expected$upper), 0.99999999)
    expect_equal(actual_obsv$time, expected$time)
    expect_equal(actual_obsv$group, expected$group)

    #
    #
    # Survival Data
    #
    #
    design <- model.matrix(~ cov_cat + cov_cont, data = dat_os)

    beta_coefs <- as.CmdStanMCMC(mp)$draws(
        c("sm_exp_lambda", "beta_os_cov"),
        format = "draws_matrix"
    )
    beta_coefs[, 1] <- log(beta_coefs[, 1])

    lambda_samples <- exp(design %*% t(beta_coefs))[c(4, 2, 50), ]

    samples_df <- dplyr::tibble(
        pt = rep(c("pt_004", "pt_002", "pt_050"), c(100, 100, 100)),
        id = rep(seq_len(100), 3),
        samples = c(lambda_samples[1, ], lambda_samples[2, ], lambda_samples[3, ])
    )

    expected <- purrr::map(
        c(0.25, 0.5, 0.75, 1.5, 2),
        \(time) {
            samples_df |> dplyr::mutate(time = time)
        }
    ) |>
        dplyr::bind_rows() |>
        dplyr::mutate(surv = pexp(time, rate = samples, lower.tail = FALSE)) |>
        dplyr::group_by(pt, time) |>
        dplyr::summarise(
            median = median(surv),
            lower = quantile(surv, 0.025),
            upper = quantile(surv, 0.975),
            .groups = "drop"
        )

    survquant <- SurvivalQuantities(
        mp,
        grid = GridFixed(
            subjects = c("pt_004", "pt_002", "pt_050"),
            times = c(0.25, 0.5, 0.75, 1.50, 2)
        )
    )
    actual <- summary(survquant) |> dplyr::arrange(group, time)

    expect_gt(cor(actual$median, expected$median), 0.99999999)
    expect_gt(cor(actual$lower, expected$lower), 0.99999999)
    expect_gt(cor(actual$upper, expected$upper), 0.99999999)
    expect_equal(actual$time, expected$time)
    expect_equal(actual$group, expected$pt)
})
