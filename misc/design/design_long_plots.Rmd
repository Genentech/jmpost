---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Design for the longitudinal fit plots

Now let's try to wrap our head around how we can produce nice longitudinal
fit plots from our joint or single longitudinal model fit.

## Example

Let's start with a simple example - the simplest is when we just have the
longitudinal model:

```{r}
single_longitudinal <- JointModel(
    longitudinal = LongitudinalRandomSlope()
)
set.seed(321)
sim_data <- simulate_joint_data(
    lm_fun = sim_lm_random_slope(),
    os_fun = sim_os_exponential(1 / 300)
)
os_data <- sim_data$os
long_data <- sim_data$lm |>
    dplyr::filter(time %in% c(1, 50, 100, 150, 200, 250, 300)) |>
    dplyr::arrange(time, pt)
library(survival)
joint_data <- DataJoint(
    survival = DataSurvival(
        data = os_data,
        formula = Surv(time, event) ~ cov_cat + cov_cont,
        subject = "pt",
        arm = "arm",
        study = "study"
    ),
    longitudinal = DataLongitudinal(
        data = long_data,
        formula = sld ~ time,
        subject = "pt",
        threshold = 5
    )
)
mcmc_results <- sampleStanModel(
    single_longitudinal,
    data = joint_data,
    iter_sampling = 500,
    iter_warmup = 500,
    chains = 1,
    parallel_chains = 1,
    exe_file = file.path("local", "single_longitudinal")
)
mcmc_results
```

It can be instructive to look at the Stan code:

```{r, eval = FALSE}
tmp <- tempfile()
write_stan(single_longitudinal, file_path = tmp)
file.edit(tmp)
```

## Obtaining longitudinal fit samples

So how do we now obtain patient specific samples of the fitted longitudinal model?

The challenge is that we cannot just take the sampled parameter samples and then 
plug them into the model and get the fit samples. The reason is that we don't have
the information contained in the `mcmc_results` about what the longitudinal model 
actually is. Even the longitudinal model itself:

```{r}
long_model <- LongitudinalRandomSlope()
str(long_model@stan)
```

does not have the model as an R function e.g. but only in Stan code form. We can
find it in the transformed parameters block:

```{r}
long_model@stan@transformed_parameters
```

### Option 1: Do it in Stan

We could generate the samples in Stan already as part of the generated quantities
block. Note that it is not sufficient to just have them at the observed time points,
because then we cannot plot nice functional fits afterwards. So we need this at a 
certain grid of time points.

Note that currently the modeled mean structure just occurs in the line 
`lm_rs_intercept + lm_rs_rslope_ind .* Tobs`.

Input to Stan (data):
- Time point grid (e.g. `lm_time_grid`)
- Length of the time point grid (e.g. `n_lm_time_grid`)

Output from Stan:
- Samples at observed time points (e.g. `Ypred`), this is a vector in parallel to
  the existing `Yobs`. This can be in transformed parameters.
- Samples at time point grid (e.g. `y_fit_at_time_grid`), this can be a matrix with
  `Nind` rows and `n_lm_time_grid` columns. This should happen in generated quantities
  because it is not needed for the log likelihood calculations and would slow
  us down otherwise unnecessarily. For now we would need to put that separately
  into each longitudinal model's Stan code. (We could think of a function convention
  and then calling the same function with the same code in generated quantities
  but that does not seem to save much, and we would need to figure out how to
  press all longitudinal parameters into the function signature which seems painful.)

We are doing this here on this branch to see how easy it is:
- We need to modify the `model.stan` file in the corresponding sub-folder for the random slope model,
- as well as `longitudinal.stan` in the base folder to arrange for the new inputs.
- In `DataLongitudinal.R` we need to add a `time_grid` slot, and importantly the
  `as.list()` method needs to return the required data points.
- We also need to adapt `base.stan` so that it will actually fetch the generated quantities
  code from the longitudinal model.

Finally we can get the samples:

```{r}
mcmc_results$summary("Ypred[1]")
mcmc_results$summary("y_fit_at_time_grid[1,1]")
```

We definitely notice that the sampling speed is lower now with the additional
generated quantities generation.

### Option 2: Do it in R

We could do it from R too. 

This would mean though that we need to separately code
the mean structure in R, and we then have to continue to maintain the consistency
of the Stan and the R code for these mean structures.

We could e.g. define a method `longitudinal_samples()` for the class 
`LongitudinalRandomSlope` that takes the longitudinal model (just for dispatch)
as well as the resulting `mcmc_results` and then grabs the right parameters from it
and produces from that the longitudinal fit samples.

Currently this would mean that the user has to save the model object and plug in here.
Better would be if we pull through this model object into the MCMC results object
and the user just operates on that. So `JointModel` needs to store it already,
and then `sampleStanModel` e.g. also returns the original `JointModel` in a slot.


